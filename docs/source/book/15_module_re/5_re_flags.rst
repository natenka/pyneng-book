Флаги
~~~~~

При использовании функций или создании скомпилированного регулярного
выражения можно указывать дополнительные флаги, которые влияют на
поведение регулярного выражения.

Модуль re поддерживает такие флаги (в скобках короткий вариант
обозначения флага): \* re.ASCII (re.A) \* re.IGNORECASE (re.I) \*
re.MULTILINE (re.M) \* re.DOTALL (re.S) \* re.VERBOSE (re.X) \*
re.LOCALE (re.L) \* re.DEBUG

В этом подразделе для примера рассматривается флаг re.DOTALL. Информация
об остальных флагах доступна в
`документации <https://docs.python.org/3/library/re.html#re.A>`__.

re.DOTALL
~~~~~~~~~

С помощью регулярных выражений можно работать и с многострочной строкой.

Например, из строки table надо получить только строки с соответствиями
VLAN-MAC-interface:

.. code:: python

    In [11]: table = '''
        ...: sw1#sh mac address-table
        ...:           Mac Address Table
        ...: -------------------------------------------
        ...:
        ...: Vlan    Mac Address       Type        Ports
        ...: ----    -----------       --------    -----
        ...:  100    aabb.cc10.7000    DYNAMIC     Gi0/1
        ...:  200    aabb.cc20.7000    DYNAMIC     Gi0/2
        ...:  300    aabb.cc30.7000    DYNAMIC     Gi0/3
        ...:  100    aabb.cc40.7000    DYNAMIC     Gi0/4
        ...:  500    aabb.cc50.7000    DYNAMIC     Gi0/5
        ...:  200    aabb.cc60.7000    DYNAMIC     Gi0/6
        ...:  300    aabb.cc70.7000    DYNAMIC     Gi0/7
        ...: '''

| Конечно, в этом случае можно разделить строку на части и работать с
каждой строкой отдельно.
| Но можно получить часть с MAC-адресами и без разделения.

В этом примере нужно вырезать часть вывода, которая содержит
соответствия.

В этом выражении описана строка с MAC-адресом:

.. code:: python

    In [12]: m = re.search(' *\d+ +[a-f0-9.]+ +\w+ +\S+', table)

В результат попадет первая строка с MAC-адресом:

.. code:: python

    In [13]: m.group()
    Out[13]: ' 100    aabb.cc80.7000    DYNAMIC     Gi0/1'

Учитывая то, что по умолчанию регулярные выражения жадные, можно
получить все соответствия таким образом:

.. code:: python

    In [14]: m = re.search('( *\d+ +[a-f0-9.]+ +\w+ +\S+\n)+', table)

    In [15]: print(m.group())
     100    aabb.cc10.7000    DYNAMIC     Gi0/1
     200    aabb.cc20.7000    DYNAMIC     Gi0/2
     300    aabb.cc30.7000    DYNAMIC     Gi0/3
     100    aabb.cc40.7000    DYNAMIC     Gi0/4
     500    aabb.cc50.7000    DYNAMIC     Gi0/5
     200    aabb.cc60.7000    DYNAMIC     Gi0/6
     300    aabb.cc70.7000    DYNAMIC     Gi0/7

Тут описана строка с MAC-адресом, перевод строки, и указано, что это
выражение должно повторяться, как минимум, один раз.

Получается, что в данном случае надо получить все строки, начиная с
первого соответствия VLAN-MAC-интерфейс.

Это можно описать таким образом:

.. code:: python

    In [16]: m = re.search(' *\d+ +[a-f0-9.]+ +\w+ +\S+.*', table)

    In [17]: print(m.group())
     100    aabb.cc10.7000    DYNAMIC     Gi0/1

| Пока что в результате только одна строка, так как по умолчанию точка
не включает в себя перевод строки.
| Но, если добавить специальный флаг, re.DOTALL, точка будет включать и
перевод строки, и в результат попадут все соответствия:

.. code:: python

    In [18]: m = re.search(' *\d+ +[a-f0-9.]+ +\w+ +\S+.*', table, re.DOTALL)

    In [19]: print(m.group())
     100    aabb.cc10.7000    DYNAMIC     Gi0/1
     200    aabb.cc20.7000    DYNAMIC     Gi0/2
     300    aabb.cc30.7000    DYNAMIC     Gi0/3
     100    aabb.cc40.7000    DYNAMIC     Gi0/4
     500    aabb.cc50.7000    DYNAMIC     Gi0/5
     200    aabb.cc60.7000    DYNAMIC     Gi0/6
     300    aabb.cc70.7000    DYNAMIC     Gi0/7

